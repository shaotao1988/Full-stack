# 如何实现一个短网址系统

短网址系统是一种将任意给定URL的长度缩短至一定长度内的服务，输出的是URL的别名，访问这个别名将跳转到原URL。输出的URL别名需要比原始URL更短，以方便对链接进行分享。

微博(www.sina.lt)、谷歌(goo.gl)等都推出了短网址服务，比如微博的短网址服务，输入https://www.quora.com/What-are-the-http-bit-ly-and-t-co-shortening-algorithms，输出的短网址为http://t.cn/Rs2VlSq

假设我们的目标是将URL表示成如下形式：http://tinyurl.com/alias. alias就是输出的原URL的别名。

为便于理解和记忆，将组成alias的字符限定为'a-z', 'A-Z', '0-9'这62个字符，同时长度不超过n。如果n为7，那么理论上系统能够支持的URL总数为62^7，约为3500 billion(十亿)，对于这个系统来说应该足够了。

很容易想到的方案就是将输入的URL通过一个哈希函数H生成一个更短的字符串，即H(URL) = alias，需要满足以下条件：
- 需要保证不同的URL哈希到不同的alias字符串，即不能发生冲突
- 通过alias字符串要能够很容易地找到对应的原始URL

哈希方案有这样几种：
- 生成随机的7位62进制字符串，比如用uuid等函数生成后截取
- 根据输入的URL生成alias，比如MD5, SHA摘要等
- 使用自增ID，将ID转换为62进制

选择hash方案需要考虑这几个因素：
- hash生成效率  
  使用随机生成字符串的方式比自增ID慢一些，同时为保证唯一性，还需要到数据库中查询一次以验证字符串是否唯一。
- 反向查找的效率  
  通过TinyURL定位到原始URL的效率。如果使用自增ID，可以通过进制转换将TinyURL直接转换为自增ID，它是主键，查找效率很高
- 功能性  
  如果使用自增ID，那么对于用户自定义短网址的功能来说可能不那么友好，因为还要检查自增的ID是否已经被占用了，失去了高效的优势。
  另外，系统可能会有URL自动失效的功能，使用自增ID的话还涉及到过期的ID如何回收利用的问题。
- 并发  
  如果是自增ID的话，ID的上界会成为争用的焦点
- 扩展性  
  如果扩展到多台服务器的话，需要考虑如何保证生成的alias全局唯一的问题。如果是自增ID的话，生成ID的那台服务器会成为单点故障。

并发一致性：
- 考虑2个用户同时请求对相同的URL生成短链接，如果是随机字符串的方式生成TinyURL，那么生成ID、检查ID唯一性、插入数据库这个过程是一个事务(大数据量时插入数据库比较慢，可以考虑通过写缓存然后用事件通知的方式异步写数据库，缺点是需要容忍掉电等导致的少量数据丢失)，而如果使用MD5或SHA这类算法的话，由于生成的TinyURL不会重复，这些操作不需要放到事务里面。
- 如果为2个不同的URL生成了相同的TinyURL，且该TinyURL之前没有被使用。

>当数据量不大时，可以用Bloom filter来判断指定的TinyURL是否被占用，它比查找数据库要快得多

考虑支持的其它功能点：
- 用户自定义的TinyURL
- TinyURL访问统计功能，比如点击数、客户端类型、操作系统、IP、点击时间等
- 用户注册、登录
- 开放API
- AAA：认证、授权、计费
- 非付费用户，生成的TinyURL一段时间后自动失效；如果变为付费用户，之前创建的TinyURL不能失效
- 网址审核，识别危险、不健康的URL，并封禁相关用户
- 限流，防止恶意注册大量短链接，占用系统资源
- 加密，只有通过验证才能正常访问原始URL


## 方案一：单服务器方案

- Flask  
  提供web界面和业务处理逻辑
- Redis  
  缓存热点数据
- MySQL  
  数据持久化

